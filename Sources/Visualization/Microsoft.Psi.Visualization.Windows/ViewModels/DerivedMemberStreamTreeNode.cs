// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.

namespace Microsoft.Psi.Visualization.ViewModels
{
    using System;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.Linq;
    using System.Reflection;
    using Microsoft.Psi.Visualization.Adapters;
    using Microsoft.Psi.Visualization.Data;
    using Microsoft.Psi.Visualization.VisualizationObjects;

    /// <summary>
    /// Implements a node in the dataset tree that represents a derived member stream,
    /// i.e. contains data corresponding to a derived field of property of a stream.
    /// </summary>
    public class DerivedMemberStreamTreeNode : DerivedStreamTreeNode
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DerivedMemberStreamTreeNode"/> class.
        /// </summary>
        /// <param name="parent">The parent stream tree node.</param>
        /// <param name="memberInfo">The member information.</param>
        /// <param name="memberType">The type of the member.</param>
        /// <param name="generateNullable">Indicates whether this is an auto-generated nullable expansion.</param>
        public DerivedMemberStreamTreeNode(StreamTreeNode parent, MemberInfo memberInfo, Type memberType, bool generateNullable)
            : base(
                parent.PartitionViewModel,
                $"{parent.Path}.{memberInfo.Name}",
                memberInfo.Name,
                parent.SourceStreamMetadata)
        {
            this.DataTypeName =
                generateNullable ?
                typeof(Nullable<>).MakeGenericType(memberType).AssemblyQualifiedName :
                memberType.AssemblyQualifiedName;
            this.MemberPath =
                parent is DerivedMemberStreamTreeNode expandedMemberParent ?
                $"{expandedMemberParent.MemberPath}.{memberInfo.Name}" :
                memberInfo.Name;
            this.IsAutoGeneratedNullableMember = generateNullable;
        }

        /// <summary>
        /// Gets the member path of this node relative to source stream node.
        /// </summary>
        [DisplayName("Member Path")]
        [Description("The path from the messages in the stream to this property or field member")]
        public string MemberPath { get; private set; }

        /// <summary>
        /// Gets or sets a value indicating whether this stream is an auto-generated nullable member.
        /// </summary>
        /// <remarks>When derived members are generated for value types, if any of the ancestor
        /// streams are of a reference type, the derived member will have a corresponding nullable value type,
        /// instead of the actual value type. This is done so that values for the member can be computed
        /// even in the case when the ancestor object is null.</remarks>
        [Browsable(false)]
        public bool IsAutoGeneratedNullableMember { get; protected set; }

        /// <inheritdoc/>
        public override StreamBinding CreateStreamBinding(VisualizerMetadata visualizerMetadata) =>
            new StreamBinding(
                this.SourceStreamMetadata.Name,
                this.PartitionViewModel.Name,
                this.Path,
                visualizerMetadata.StreamAdapterType,
                visualizerMetadata.VisualizationObjectType == typeof(LatencyVisualizationObject) || visualizerMetadata.VisualizationObjectType == typeof(MessageVisualizationObject) ? null : new object[] { this.MemberPath },
                visualizerMetadata.SummarizerType,
                null,
                true);

        /// <inheritdoc/>
        public override void EnsureDerivedStreamExists(StreamBinding streamBinding)
        {
            var memberPath = streamBinding.StreamAdapterArguments[0] as string;
            if (memberPath.StartsWith($"{this.MemberPath}."))
            {
                var remainingPath = memberPath.Substring(this.MemberPath.Length + 1);

                if (this.FindStreamTreeNode(remainingPath) == null)
                {
                    this.AddDerivedMemberStreamChildren();
                    this.ExpandAll();
                }

                if (remainingPath.Contains('.'))
                {
                    var pathItems = remainingPath.Split('.');
                    if (this.InternalChildren.FirstOrDefault(p => p.Name == pathItems.First()) is DerivedMemberStreamTreeNode memberChild)
                    {
                        memberChild.EnsureDerivedStreamExists(streamBinding);
                    }
                }
            }
        }

        /// <inheritdoc/>
        protected override void InsertCustomAdapters(List<VisualizerMetadata> metadatas)
        {
            var streamSourceDataType = VisualizationContext.Instance.GetDataType(this.SourceStreamMetadata.TypeName);

            // For each of the non-universal visualization objects, add a data adapter from the stream data type to the subfield data type
            for (int index = 0; index < metadatas.Count; index++)
            {
                // For message visualization object insert a custom object adapter so values can be displayed for known types.
                if (metadatas[index].VisualizationObjectType == typeof(MessageVisualizationObject))
                {
                    var objectAdapterType = typeof(ObjectAdapter<>).MakeGenericType(streamSourceDataType);
                    metadatas[index] = metadatas[index].GetCloneWithNewStreamAdapterType(objectAdapterType);
                }
                else if (metadatas[index].VisualizationObjectType == typeof(LatencyVisualizationObject))
                {
                    // O/w for latency visualization object insert a custom object adapter so values can be displayed for known types.
                    var objectToLatencyAdapterType = typeof(ObjectToLatencyAdapter<>).MakeGenericType(streamSourceDataType);
                    metadatas[index] = metadatas[index].GetCloneWithNewStreamAdapterType(objectToLatencyAdapterType);
                }
                else
                {
                    // If the visualizer metadata already contains a stream adapter, create a stream member adapter that
                    // encapsulates it, otherwise create a stream member adapter that adapts directly from the message
                    // type to the member type.
                    Type streamMemberAdapterType;
                    if (metadatas[index].StreamAdapterType != null)
                    {
                        var existingStreamAdapter = (IStreamAdapter)Activator.CreateInstance(metadatas[index].StreamAdapterType);
                        streamMemberAdapterType = typeof(StreamMemberAdapter<,,,>).MakeGenericType(
                            streamSourceDataType,
                            existingStreamAdapter.SourceType,
                            metadatas[index].StreamAdapterType,
                            existingStreamAdapter.DestinationType);
                    }
                    else
                    {
                        streamMemberAdapterType = typeof(StreamMemberAdapter<,>).MakeGenericType(
                            streamSourceDataType,
                            metadatas[index].DataType);
                    }

                    metadatas[index] = metadatas[index].GetCloneWithNewStreamAdapterType(streamMemberAdapterType);
                }
            }
        }

        /// <inheritdoc/>
        protected override void AddDerivedMemberStreamChildren()
        {
            // Get the type of this node.
            Type dataType = TypeResolutionHelper.GetVerifiedType(this.DataTypeName);

            // If this is already an auto-generated nullable, then the type we care to expand is
            // the value-type inside the nullable type.
            if (this.IsAutoGeneratedNullableMember)
            {
                dataType = dataType.GenericTypeArguments[0];
            }

            // Determine if the current node is a reference type
            var isReference = this.IsAutoGeneratedNullableMember || !dataType.IsValueType || Nullable.GetUnderlyingType(dataType) != null;

            if (dataType != null)
            {
                // Add a child node for each public instance property that takes no parameters.
                foreach (PropertyInfo propertyInfo in dataType.GetProperties(BindingFlags.Public | BindingFlags.Instance).Where(property => !property.GetMethod.GetParameters().Any()))
                {
                    this.AddDerivedMemberStreamChild(propertyInfo, propertyInfo.PropertyType, isReference && propertyInfo.PropertyType.IsValueType);
                }

                // Add a child node for each public instance field
                foreach (FieldInfo fieldInfo in dataType.GetFields(BindingFlags.Public | BindingFlags.Instance))
                {
                    this.AddDerivedMemberStreamChild(fieldInfo, fieldInfo.FieldType, isReference && fieldInfo.FieldType.IsValueType);
                }
            }
        }

        /// <inheritdoc/>
        protected override bool CanExpandDerivedMemberStreams()
        {
            // Get the node type
            Type nodeType = TypeResolutionHelper.GetVerifiedType(this.DataTypeName);

            // If it's an auto-generated nullable, we need to assess whether the inner value-type (inside the nullable)
            // can expand the members.
            if (this.IsAutoGeneratedNullableMember)
            {
                nodeType = nodeType.GenericTypeArguments[0];
            }

            if (nodeType != null)
            {
                return nodeType.GetProperties(BindingFlags.Public | BindingFlags.Instance).Where(property => !property.GetMethod.GetParameters().Any()).Any() || nodeType.GetFields(BindingFlags.Public | BindingFlags.Instance).Any();
            }

            return false;
        }
    }
}
